<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>代理模式在vue.js的应用 | taild个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="说明本文主要讲解vue.js中如何运用代理模式，让代码更纯粹。以及运用类似工厂模式的方法，将各种代理方法通过注册的方式添加到代理工厂里面去，这样各种代理的实现就能独立出来，实现代码的松耦合 问题引发的思考这里选举最简单最常见的例子，在项目中每当涉及删除的时候，都需要先提示，确认删除，然后再删除。这是正常的逻辑。防止用户误操作，因为这些过程都是不可逆的。列如（这里用了element-ui组件）：用户">
<meta name="keywords" content="vue.js、代理模式">
<meta property="og:type" content="article">
<meta property="og:title" content="代理模式在vue.js的应用">
<meta property="og:url" content="http://tld-uuid.github.io/2018/07/28/vue-methods-proxy/index.html">
<meta property="og:site_name" content="taild个人博客">
<meta property="og:description" content="说明本文主要讲解vue.js中如何运用代理模式，让代码更纯粹。以及运用类似工厂模式的方法，将各种代理方法通过注册的方式添加到代理工厂里面去，这样各种代理的实现就能独立出来，实现代码的松耦合 问题引发的思考这里选举最简单最常见的例子，在项目中每当涉及删除的时候，都需要先提示，确认删除，然后再删除。这是正常的逻辑。防止用户误操作，因为这些过程都是不可逆的。列如（这里用了element-ui组件）：用户">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-07-28T08:50:21.907Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代理模式在vue.js的应用">
<meta name="twitter:description" content="说明本文主要讲解vue.js中如何运用代理模式，让代码更纯粹。以及运用类似工厂模式的方法，将各种代理方法通过注册的方式添加到代理工厂里面去，这样各种代理的实现就能独立出来，实现代码的松耦合 问题引发的思考这里选举最简单最常见的例子，在项目中每当涉及删除的时候，都需要先提示，确认删除，然后再删除。这是正常的逻辑。防止用户误操作，因为这些过程都是不可逆的。列如（这里用了element-ui组件）：用户">
  
    <link rel="alternate" href="/atom.xml" title="taild个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">taild个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">前端技术分享，追求高质量文章，拒绝对已有技术文档搬运。全部原创，拒绝抄袭，欢迎讨论qq:394733875@qq.com</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://tld-uuid.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-vue-methods-proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/28/vue-methods-proxy/" class="article-date">
  <time datetime="2018-07-28T04:21:18.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      代理模式在vue.js的应用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文主要讲解vue.js中如何运用代理模式，让代码更纯粹。以及运用类似工厂模式的方法，将各种代理方法通过注册的方式添加到代理工厂里面去，这样各种代理的实现就能独立出来，实现代码的松耦合</p>
<h2 id="问题引发的思考"><a href="#问题引发的思考" class="headerlink" title="问题引发的思考"></a>问题引发的思考</h2><p>这里选举最简单最常见的例子，在项目中每当涉及删除的时候，都需要先提示，确认删除，然后再删除。这是正常的逻辑。防止用户误操作，因为这些过程都是不可逆的。<br>列如（这里用了element-ui组件）：<br>用户点击删除按钮，按钮绑定deleteObject方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 省略vue文件中的其他代码</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  deleteObject (id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$confirm(<span class="string">'确定删除?'</span>, <span class="string">'提示'</span>, &#123;</span><br><span class="line">      confirmButtonText: <span class="string">'确定'</span>,</span><br><span class="line">      cancelButtonText: <span class="string">'取消'</span>,</span><br><span class="line">      type: <span class="string">'warning'</span>,</span><br><span class="line">      lockScroll: <span class="literal">false</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里省略删除数据的代码...包括调用后端</span></span><br><span class="line">      <span class="comment">// this.$http.delete(url,&#123;id:id&#125;)</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>刚开始写看起来一切很正常，也没什么毛病。但是，写着写着就会发现，这种代码充斥这整个代码，和业务（例如删除）耦合在一起，而且都是重复的。我希望这个方法更纯粹一点，就是删除逻辑，没有其他不相关的代码。<br>可能有人觉得，现在怎么就不纯粹了，提示也是应该明确给出的。那我说另外一个需求，<strong>阻止用户连续点击</strong>，有些按钮点击之后是需要发送请求的，不能让用户卡卡卡不停的点击。<br>还有，比如，用户搜索过程中每次输入结束都调用后台，但是只要用户不停输入就不发送请求，这些方法是需要<strong>debounce、throttle</strong>化处理的。debounce、throttle不懂的话不过多介绍，自行搜索。<br>以前的做法是定义个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDoing = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isDoing)&#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   isDoing = <span class="literal">true</span></span><br><span class="line">   <span class="comment">// 之后的某个时机请求回来或者失败。或者固定时长之后isDoing =false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在代码肯定不纯粹了，业务量大，很影响维护。看着也难受</p>
<h2 id="如何解决呢"><a href="#如何解决呢" class="headerlink" title="如何解决呢"></a>如何解决呢</h2><p>搞过后端（这里指Java）的人肯定知道，用代理模式，JDK、cglib，调用代理方法，代理方法去做删除的提示啊、控制执行、延迟执行等等。当符合条件时，再调用被代理的方法。<br><strong>在vuejs中如何实现呢？</strong><br>要代理的方法是methods定义的方法，不能影响到vue.js的绑定处理</p>
<p>先说明确需求，有两种使用方式：<br>1、所有以delete开头的方法，自动运用删除提示代理<br>2、通过明确的配置，实现代理</p>
<p>两个各有优缺点<br>1、优点：</p>
<ul>
<li>无需配置，使用简单<br>缺点：</li>
<li>不明确，毕竟JavaScript没有Java的注解</li>
<li>需要代理实现遍历所有的methods方法，做相应名称匹配，很有可能会误操作。</li>
<li>不利于扩展，无法传递给代理方法参数。以后增加各种代理需求，会很复杂<br>2、优点：<ul>
<li>配置明确、一目了然</li>
<li>参数可以自定义<br>缺点：</li>
<li>需要配置，有点麻烦</li>
<li>配置会污染vue.js的属性</li>
</ul>
</li>
</ul>
<p>各方权衡，选择配置的方式，自动遍历代理不利于代码阅读和理解，就像机关暗门藏在里面。当然，没有什么比一目了然的代码更让人喜欢。至于配置会污染vue.js的属性。这里可采用一个命名空间的方式。以公司名称（或缩写）做属性，就算以后和vue冲突（概率很低）,也方便修改</p>
<h2 id="vue-扩展"><a href="#vue-扩展" class="headerlink" title="vue-扩展"></a>vue-扩展</h2><p>vue单文件组件，属性值有：props、data、methods…不列举了。<br>现在做扩展、自定义一个属性名：xxxConfig( xxx建议取公司名)，这样减少以后冲突的几率<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 这里是vue 其他属性 data、computed等等</span></span><br><span class="line">   <span class="comment">// xxxConfig下面所有的配置都是自定义的，不是vue的，不要误会，当然，配置需要相应的实现代码来支撑（后面讲）</span></span><br><span class="line">   xxxConfig:&#123; <span class="comment">// 自定义，vue模板的配置，统一采用xxConfig,采用一个命名空间namespace，以后的所有对vue的扩展，全部放入xxxConfig下面</span></span><br><span class="line">     methodProxy: &#123; <span class="comment">// 对方法的扩展，即方法代理配置</span></span><br><span class="line">       confirm: &#123; <span class="comment">// 代理的类型: 'confirm'（二次确认，多用于删除之类的）。（注意：该代理需要手动注册，这是因为，移动端和pc端实现代理方式有差异）</span></span><br><span class="line">         methodNames: [<span class="string">'onDeleteObj'</span>] <span class="comment">// 需要进行删除代理的方法，每次调用onDeleteObj都会提示是否删除，让用户确认，但是onDeleteObj方法里面并没有提示代码</span></span><br><span class="line">       &#125;,</span><br><span class="line">        params: &#123; <span class="comment">// 定制化参数（默认可以不传）,该参数会传给代理函数</span></span><br><span class="line">         onDeleteObj: &#123; <span class="comment">// 代理方法需要参数，名称'onDeleteObj'就是methodNames里面需要代理的方法名。</span></span><br><span class="line">           title: <span class="string">'提示'</span>, <span class="comment">// 这里举例是element-ui,$confirm的参数</span></span><br><span class="line">           message: <span class="string">'确定删除'</span>,</span><br><span class="line">           options: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    .... <span class="comment">// 省略其他对vue的扩展，为以后扩展留下空间</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">   onDeleteObj (args)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'调用我之前会弹出提示，但是我并不关心'</span>)</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'如果我的参数args是绑定在@click指令里面传入的，那么args依然能正确传入'</span>,args)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像上面那样，onDeleteObj被代理了，但是它不知道，也无需关心。同时methodProxy下面的methodNames可以同时配置多个方法名称</p>
<p>需求很明确，代码很迷茫。不能光说不做，实现上面的代理需求。同时运用工厂方式，统一收集各种代理</p>
<h2 id="实现代理"><a href="#实现代理" class="headerlink" title="实现代理"></a>实现代理</h2><h3 id="以上面删除提示为例子-实现一个类型为confirm-的代理方法"><a href="#以上面删除提示为例子-实现一个类型为confirm-的代理方法" class="headerlink" title="以上面删除提示为例子,实现一个类型为confirm 的代理方法"></a>以上面删除提示为例子,实现一个类型为confirm 的代理方法</h3><p>新建confirm-proxy.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultParams = &#123;</span><br><span class="line">  message: <span class="string">'确定删除?'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    title: <span class="string">'提示'</span>,</span><br><span class="line">    confirmButtonText: <span class="string">'确定'</span>,</span><br><span class="line">    cancelButtonText: <span class="string">'取消'</span>,</span><br><span class="line">    type: <span class="string">'warning'</span>,</span><br><span class="line">    lockScroll: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params fn 被代理的方法</span></span><br><span class="line"><span class="comment"> * @params options 参数</span></span><br><span class="line"><span class="comment"> * @return 代理方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">confirmProxy</span> (<span class="params">fn, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params = <span class="built_in">Object</span>.assign(defaultParams, options) <span class="comment">// 注:参数层级超过两层，需要merge方式</span></span><br><span class="line">  <span class="keyword">let</span> target = fn</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// **注:这里不要用箭头函数，因为你代理的是vue methods里面的方法，代理方法会被vue处理、无法绑定vue this **</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// window.app 是全局根实例</span></span><br><span class="line">    <span class="comment">/* window.app = new Vue(&#123;</span></span><br><span class="line"><span class="comment">         el: '#app',</span></span><br><span class="line"><span class="comment">         router,</span></span><br><span class="line"><span class="comment">         store,</span></span><br><span class="line"><span class="comment">         render: h =&gt; h(App)</span></span><br><span class="line"><span class="comment">      &#125;)*/</span></span><br><span class="line">    <span class="comment">// 你也可以用其他的提示方法，这里只是说明</span></span><br><span class="line">    <span class="built_in">window</span>.app.$confirm(params.message, params.options).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      target.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'confirm'</span>,</span><br><span class="line">  fn: confirmProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个代理都是一个单独的文件（这里 confirm-proxy.js），<strong>代理名称-proxy为文件名</strong>，默认导出代理类型名称和代理方法。</p>
<h4 id="confirm代理的运用"><a href="#confirm代理的运用" class="headerlink" title="confirm代理的运用"></a>confirm代理的运用</h4><p>自定义vue插件, 一般中大型项目的开发都会有自定义的vue插件，和公司业务、其他框架结合。<br>这里我只写有关代理的代码，其他省略、<br>customVuePlugin.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxyFactory <span class="keyword">from</span> <span class="string">'./proxy-factory.js'</span> <span class="comment">// 代理工厂、所有代理注册在里面，稍后讲</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> namespace = <span class="string">'xxxConfig'</span> <span class="comment">// 自定义vue扩展的命名属性</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      <span class="comment">// 从配置中读取是否有需要代理的方法,proxyConfig中的属性，参考上述的配置</span></span><br><span class="line">      <span class="keyword">let</span> proxyConfig = <span class="keyword">this</span>.$options[namespace] ? <span class="keyword">this</span>.$options[namespace].methodProxy : <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (!proxyConfig) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历代理配置，去代理需要代理的方法</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(proxyConfig).forEach(<span class="function">(<span class="params">proxyType</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> configItem = proxyConfig[proxyType]</span><br><span class="line">        <span class="keyword">let</span> proxyMethod = proxyFactory.getProxyMethod(proxyType) <span class="comment">// 从代理工厂中获取相应的代理方法</span></span><br><span class="line">        <span class="keyword">let</span> methodNames = configItem.methodNames <span class="comment">// 需要代理的函数数组</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(methodNames) || methodNames.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[gx proxy warn]: methodNames must be array and length &gt; 1`</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        methodNames.forEach(<span class="function">(<span class="params">methodName</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> fn = <span class="keyword">this</span>.$options.methods[methodName]</span><br><span class="line">          <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">`[gx proxy warn]: method <span class="subst">$&#123;methodName&#125;</span> is not exist`</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> options = &#123;&#125;</span><br><span class="line">          <span class="keyword">if</span> (configItem.params &amp;&amp; configItem.params[methodName]) &#123; <span class="comment">// 配置参数</span></span><br><span class="line">            options = configItem.params[methodName]</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.$options.methods[methodName] = proxyMethod(fn, options) <span class="comment">// 覆盖原来的方法，因为是beforeCreate生命周期，vue还没有做相应的绑定</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install (Vue) &#123;</span><br><span class="line">    _addMixin(Vue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>最为关键的一句proxyFactory.getProxyMethod(proxyType)</strong><br>参数proxyType就是confirm代理类型。这句话就是从代理工厂中获取代理类型为’confirm’的代理方法，这里有点绕口<br>proxy-factory.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.proxyConfig = &#123;&#125; <span class="comment">// 存放所有代理类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册 代理类型、方法</span></span><br><span class="line"><span class="comment">   * @param type</span></span><br><span class="line"><span class="comment">   * @param fn</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  register = <span class="function">(<span class="params">type, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.proxyConfig[type]) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`代理类型[<span class="subst">$&#123;type&#125;</span>]已经存在，不能重复注册，请检查注册代码`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.proxyConfig[type] = fn</span><br><span class="line">  &#125;</span><br><span class="line">  getProxyMethod = <span class="function">(<span class="params">proxyType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.proxyConfig[proxyType]) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`代理类型配置有误，不存在该代理类型:<span class="subst">$&#123;proxyType&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.proxyConfig[proxyType]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> ProxyFactory()</span><br></pre></td></tr></table></figure></p>
<p>接下来要做的就是将代理类型comfirm注册到ProxyFactory中去<br>先思考一个问题，这里的代理类型、代理方法是根据不同业务需要开发的，是可变的。而代理工厂、vue插件中的实现methods代理的代码是不变的，将不可变的代码从中分离出来，进行复用，这不正是软件复用的思想吗。<br>如果有一些代理类型、vue扩展是通用的那么也可以放在一起。这些固定不变的、通用的代码可以放到基础工程里面去，参考<a href="/2018/07/19/build-front-base-project">基础工程</a></p>
<h3 id="注册代理类型"><a href="#注册代理类型" class="headerlink" title="注册代理类型"></a>注册代理类型</h3><p>最简单方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxyFactory <span class="keyword">from</span> <span class="string">'./proxy-factory.js'</span></span><br><span class="line"><span class="keyword">import</span> confirm <span class="keyword">from</span> <span class="string">'./confirm-proxy.js'</span></span><br><span class="line"></span><br><span class="line">proxyFactory.register(confirm.name,confirm.fn)</span><br></pre></td></tr></table></figure></p>
<p>这样上面vue插件中的<br>let proxyMethod = proxyFactory.getProxyMethod(proxyType) // 从代理工厂中获取相应的代理方法<br>上面这句话就有了着落<br>为了便于管理，应该新建一个目录假设叫vue-method-proxy（你可以任意取），专门用来存放各种代理的实现，并提供一个入口index.js</p>
<p>index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> confirmProxy <span class="keyword">from</span> <span class="string">'./confirm-proxy.js'</span></span><br><span class="line"><span class="comment">// import xxxProxy from './xxx-proxy.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  confirmProxy</span><br><span class="line">]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将自定义的代理类型和方法注册到代理工厂</span></span><br><span class="line"><span class="comment"> * @param proxyFactory 定义在基础工程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">registerTo</span> (<span class="params">proxyFactory</span>) </span>&#123;</span><br><span class="line">  list.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    proxyFactory.register(item.name, item.fn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  registerTo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>只要用index.js去注册一下就可以，以后再添加新的代理，只要关注新文件和index就可以了</strong>。无需关注太多东西<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> methodProxyList <span class="keyword">from</span> <span class="string">'vue-method-proxy/index.js'</span></span><br><span class="line"><span class="keyword">import</span> proxyFactory <span class="keyword">from</span> <span class="string">'proxy-factory.js'</span></span><br><span class="line">methodProxyList.registerTo(proxyFactory)</span><br></pre></td></tr></table></figure></p>
<p>这样便于管理，以后有新的需求，比如要实现方法的debounce代理<br>在vue-method-proxy新建一个debounce-proxy.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对func做延迟触发，防止多次调用，多用于用于搜索请求，事件监听</span></span><br><span class="line"><span class="comment"> * @param func</span></span><br><span class="line"><span class="comment"> * @param delay</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceProxy</span> (<span class="params">fn, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params = <span class="built_in">Object</span>.assign(defaultParams, options)</span><br><span class="line">  <span class="keyword">return</span> debounce(fn, params.delay)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'debounce'</span>,</span><br><span class="line">  fn: debounceProxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将debounce-proxy.js注册到index中去<br>修改下index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> confirmProxy <span class="keyword">from</span> <span class="string">'./confirm-proxy.js'</span></span><br><span class="line">+<span class="keyword">import</span> debounceProxy <span class="keyword">from</span> <span class="string">'./debounce-proxy.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  confirmProxy,</span><br><span class="line">+ debounceProxy</span><br><span class="line">]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将自定义的代理类型和方法注册到代理工厂</span></span><br><span class="line"><span class="comment"> * @param proxyFactory 定义在基础工程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">registerTo</span> (<span class="params">proxyFactory</span>) </span>&#123;</span><br><span class="line">  list.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    proxyFactory.register(item.name, item.fn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  registerTo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就可以在你的vue文件中直接使用debounce-proxy<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  gxConfig:&#123;</span><br><span class="line">     methodProxy: &#123; <span class="comment">// 故乡云代理配置</span></span><br><span class="line">       debounce: &#123; <span class="comment">// 代理的类型: confirm（二次确认，多用于删除之类的）。（注意：该代理需要手动注册，这是因为，移动端和pc端实现代理方式有差异）</span></span><br><span class="line">         methodNames: [<span class="string">'queryList'</span>] <span class="comment">// queryList方法需要被debounce化</span></span><br><span class="line">       &#125;,</span><br><span class="line">        params: &#123; <span class="comment">//</span></span><br><span class="line">         queryList: &#123;</span><br><span class="line">           delay: <span class="number">500</span> <span class="comment">// queryList延迟500毫秒执行</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    queryList () &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'我延迟调用了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对vue的methods代理的扩展就算完成了，这里vue的扩展仅仅对methods做了处理。还可以加入其他的扩展，建议使用单一的属性(我更喜欢叫命名空间)xxxConfig(xxx公司名称，防止以后冲突)。<br>这篇文章涉及JavaScript代理模式、工厂模式，主要是分离关注点，将不变的代码从可变的分离出去。提高代码复用。<br>对vue.js的扩展其实只是次要的，不要用什么框架都可以自定义扩展。思想先于代码，不要被固定模式给困住</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tld-uuid.github.io/2018/07/28/vue-methods-proxy/" data-id="cjk54pb0t0000s8t35g082ans" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-js、代理模式/">vue.js、代理模式</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/07/19/build-front-base-project/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">搭建前端基础工程</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-js、代理模式/">vue.js、代理模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端、基础工程/">前端、基础工程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/vue-js、代理模式/" style="font-size: 10px;">vue.js、代理模式</a> <a href="/tags/前端、基础工程/" style="font-size: 10px;">前端、基础工程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/28/vue-methods-proxy/">代理模式在vue.js的应用</a>
          </li>
        
          <li>
            <a href="/2018/07/19/build-front-base-project/">搭建前端基础工程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 taild<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>